#!/bin/bash
#
# Author: PB and Claude
# Date: 2025-07-18
# License: (c) HRDAG, 2025, GPL-2 or newer
#
# ------
# zfs-fd/zfs-fd-cleanup
#
# ‚ö†Ô∏è  CRITICAL WARNING ‚ö†Ô∏è
# CLONE_BASE must ALWAYS be deep_chll/tmp/zfs-fd-analysis
# NEVER use deep_chll/backup/* as these are production datasets!
# This script DESTROYS everything under CLONE_BASE - using the wrong path
# could result in catastrophic data loss!
#
# Usage: zfs-fd-cleanup [--yes] [--holds-only] [clone-base] [snapshot-tag]
# 
# Cleans up cloned datasets and removes snapshots
# ALWAYS releases holds to prevent blocking replication
# Uses environment variables or accepts command line arguments

set -euo pipefail

# Load the latest environment file if it exists
env_file=$(ls -t /var/lib/zfs-fd/*/environment.sh 2>/dev/null | head -n1)
if [[ -f "$env_file" ]]; then
    echo "üìÑ Loading environment from: $env_file"
    source "$env_file"
    echo "‚úÖ Environment loaded successfully"
    echo "   Snapshot tag: $ZFS_FD_SNAPTAG"
    echo "   Clone base: $ZFS_FD_CLONE_BASE"
else
    echo "‚ö†Ô∏è  No environment file found"
    echo "   Will use command line arguments or defaults"
fi

# Parse command line arguments
SKIP_CONFIRMATION=false
HOLDS_ONLY=false
CLONE_BASE=""
SNAPSHOT_TAG=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --yes|-y)
            SKIP_CONFIRMATION=true
            shift
            ;;
        --holds-only)
            HOLDS_ONLY=true
            shift
            ;;
        -*|--*)
            echo "Unknown option: $1" >&2
            echo "Usage: $0 [--yes] [--holds-only] [clone-base] [snapshot-tag]" >&2
            exit 1
            ;;
        *)
            if [[ -z "$CLONE_BASE" ]]; then
                CLONE_BASE="$1"
            else
                SNAPSHOT_TAG="$1"
            fi
            shift
            ;;
    esac
done

# Use environment variables if no command line arguments provided
if [[ -z "$CLONE_BASE" ]]; then
    CLONE_BASE="${ZFS_FD_CLONE_BASE:-deep_chll/tmp/zfs-fd-analysis}"
fi

if [[ -z "$SNAPSHOT_TAG" ]]; then
    SNAPSHOT_TAG="${ZFS_FD_SNAPTAG:-zfs-fd}"
fi

# Set up logging
if [[ -n "${ZFS_FD_LOG_FILE:-}" ]]; then
    LOG_FILE="$ZFS_FD_LOG_FILE"
else
    LOG_FILE="/tmp/zfs-fd-cleanup-$(date -Iseconds).log"
fi

# Log function
log() {
    echo "$(date -Iseconds) [zfs-fd-cleanup] $1" | tee -a "$LOG_FILE"
}

# CRITICAL FUNCTION: Release all du-holder holds
# This MUST succeed to prevent blocking replication
release_all_du_holder_holds() {
    echo ""
    echo "üîì CRITICAL: Checking for du-holder holds that block replication..."
    log "Starting critical du-holder hold cleanup"
    
    # Find ALL du-holder snapshots across the entire system
    local du_snapshots=$(zfs list -t snapshot -H -o name 2>/dev/null | grep "du-holder" || true)
    
    if [[ -z "$du_snapshots" ]]; then
        echo "‚úÖ No du-holder snapshots found"
        log "No du-holder snapshots found"
        return 0
    fi
    
    local total_count=$(echo "$du_snapshots" | wc -l)
    local holds_count=0
    local released_count=0
    local failed_count=0
    
    echo "Found $total_count du-holder snapshots, checking for holds..."
    
    # Check each snapshot for holds
    while IFS= read -r snap; do
        [[ -z "$snap" ]] && continue
        
        # Check if this snapshot has our hold
        if sudo zfs holds -H "$snap" 2>/dev/null | grep -q "du_analysis_hold"; then
            ((holds_count++))
            log "Found hold on $snap"
            
            # Release the hold
            if sudo zfs release du_analysis_hold "$snap" 2>&1; then
                echo "‚úÖ Released hold on: $snap"
                log "Released hold on $snap"
                ((released_count++))
            else
                echo "‚ùå FAILED to release hold on: $snap" >&2
                log "ERROR: Failed to release hold on $snap"
                ((failed_count++))
            fi
        fi
    done <<< "$du_snapshots"
    
    echo ""
    echo "üìä Hold cleanup summary:"
    echo "   - Total du-holder snapshots: $total_count"
    echo "   - Snapshots with holds: $holds_count"
    echo "   - Holds released: $released_count"
    echo "   - Failed releases: $failed_count"
    
    log "Hold cleanup complete: $total_count snapshots, $holds_count had holds, $released_count released, $failed_count failed"
    
    if [[ $failed_count -gt 0 ]]; then
        echo ""
        echo "‚ö†Ô∏è  WARNING: Failed to release $failed_count holds!"
        echo "   This WILL block replication. Manual intervention required."
        log "WARNING: Failed to release $failed_count holds - replication may be blocked"
        return 1
    fi
    
    # Now offer to destroy the snapshots
    if [[ $total_count -gt 0 ]] && [[ "$HOLDS_ONLY" == "false" ]]; then
        echo ""
        echo "üóëÔ∏è  Found $total_count du-holder snapshots that can be destroyed"
        
        if [[ "$SKIP_CONFIRMATION" == "false" ]]; then
            read -p "Destroy all du-holder snapshots? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Skipping snapshot destruction"
                return 0
            fi
        fi
        
        local destroyed=0
        local failed_destroy=0
        
        while IFS= read -r snap; do
            [[ -z "$snap" ]] && continue
            
            if sudo zfs destroy "$snap" 2>/dev/null; then
                echo "‚úÖ Destroyed: $snap"
                log "Destroyed snapshot $snap"
                ((destroyed++))
            else
                echo "‚ùå Failed to destroy: $snap"
                log "ERROR: Failed to destroy snapshot $snap"
                ((failed_destroy++))
            fi
        done <<< "$du_snapshots"
        
        echo ""
        echo "üìä Destroyed $destroyed snapshots, $failed_destroy failed"
        log "Snapshot destruction: $destroyed destroyed, $failed_destroy failed"
    fi
    
    return 0
}

# ALWAYS run hold cleanup first - this is CRITICAL
release_all_du_holder_holds
HOLD_CLEANUP_RESULT=$?

# If only doing holds, exit now
if [[ "$HOLDS_ONLY" == "true" ]]; then
    echo ""
    echo "‚úÖ Hold cleanup complete (--holds-only mode)"
    exit $HOLD_CLEANUP_RESULT
fi

log "Starting cleanup process"
log "Clone base: $CLONE_BASE"
log "Snapshot tag: $SNAPSHOT_TAG"

# Check if clone base exists
CLONE_BASE_EXISTS=true
if ! zfs list "$CLONE_BASE" >/dev/null 2>&1; then
    echo "INFO: Clone base $CLONE_BASE does not exist - nothing to clean up"
    log "INFO: Clone base $CLONE_BASE does not exist"
    CLONE_BASE_EXISTS=false
fi

if [[ "$CLONE_BASE_EXISTS" == "true" ]]; then
    # Get the root dataset name
    ROOT_CLONE_DATASET=$(zfs list -H -o name "$CLONE_BASE" 2>/dev/null | head -1)
    if [[ -z "$ROOT_CLONE_DATASET" ]]; then
        echo "ERROR: Could not determine root clone dataset"
        log "ERROR: Could not determine root clone dataset"
        exit 1
    fi

    # Get list of datasets to clean up
    DATASETS=$(zfs list -H -r -o name "$ROOT_CLONE_DATASET" | sort -r)  # Reverse order for proper cleanup
    DATASET_COUNT=$(echo "$DATASETS" | wc -l)

    echo ""
    echo "üßπ Cleanup process starting..."
    echo "üìÅ Clone base: $CLONE_BASE"
    echo "üìä Datasets to remove: $DATASET_COUNT"

    # Show what will be cleaned up
    echo ""
    echo "Datasets to be destroyed:"
    echo "$DATASETS" | while read -r ds; do
        echo "  - $ds"
    done

    # Confirmation prompt
    if [[ "$SKIP_CONFIRMATION" == "false" ]]; then
        echo ""
        read -p "Proceed with cleanup? This will destroy all cloned datasets. [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cleanup cancelled."
            log "Cleanup cancelled by user"
            exit 0
        fi
    fi

    # Check for mounts and unmount
    if mount | grep -q "$CLONE_BASE"; then
        echo "Found mounted filesystems at $CLONE_BASE"
        log "Unmounting $CLONE_BASE"
        if sudo umount -R "$CLONE_BASE" 2>/dev/null; then
            echo "‚úÖ Unmounted: $CLONE_BASE"
            log "SUCCESS: Unmounted $CLONE_BASE"
        else
            echo "‚ö†Ô∏è  Standard unmount failed, trying force unmount..."
            log "WARNING: Standard unmount failed, trying force"
            if sudo umount -f -R "$CLONE_BASE" 2>/dev/null; then
                echo "‚úÖ Force unmounted: $CLONE_BASE"
                log "SUCCESS: Force unmounted $CLONE_BASE"
            else
                echo "‚ö†Ô∏è  Could not unmount, proceeding anyway..."
                log "WARNING: Could not unmount, proceeding anyway"
            fi
        fi
    else
        echo "‚úÖ No filesystems mounted at $CLONE_BASE"
        log "INFO: No filesystems mounted at $CLONE_BASE"
    fi

    # Destroy datasets
    log "Starting dataset destruction"
    echo ""
    echo "üóëÔ∏è  Destroying datasets..."
    
    if sudo zfs destroy -r "$ROOT_CLONE_DATASET" 2>/dev/null; then
        echo "‚úÖ Recursively destroyed all datasets under: $ROOT_CLONE_DATASET"
        log "SUCCESS: Recursively destroyed $ROOT_CLONE_DATASET"
        DESTROYED_COUNT=$DATASET_COUNT
        FAILED_COUNT=0
    else
        echo "‚ö†Ô∏è  Recursive destroy failed, attempting individual destruction..."
        log "WARNING: Recursive destroy failed, attempting individual destruction"
        
        DESTROYED_COUNT=0
        FAILED_COUNT=0
        
        while IFS= read -r dataset; do
            log "Destroying $dataset"
            if sudo zfs destroy "$dataset" 2>/dev/null; then
                echo "‚úÖ Destroyed: $dataset"
                log "SUCCESS: Destroyed $dataset"
                ((DESTROYED_COUNT++))
            else
                echo "‚ùå Failed to destroy: $dataset" >&2
                log "ERROR: Failed to destroy $dataset"
                ((FAILED_COUNT++))
            fi
        done <<< "$DATASETS"
    fi

    log "Dataset destruction complete: $DESTROYED_COUNT destroyed, $FAILED_COUNT failed"
fi

# Final verification
echo ""
echo "üîç Final verification..."

REMAINING_CLONES=$(zfs list -H -o name 2>/dev/null | grep -c "zfs-fd-analysis" || true)
REMAINING_MOUNTS=$(mount | grep -c "${CLONE_BASE:-zfs-fd-analysis}" || true)
REMAINING_DU_HOLDERS=$(zfs list -t snapshot -H -o name 2>/dev/null | grep -c "du-holder" || true)

echo "  - Remaining clone datasets: $REMAINING_CLONES"
echo "  - Remaining mount points: $REMAINING_MOUNTS"
echo "  - Remaining du-holder snapshots: $REMAINING_DU_HOLDERS"

log "Final verification: $REMAINING_CLONES clones, $REMAINING_MOUNTS mounts, $REMAINING_DU_HOLDERS du-holders"

# Summary
if [[ $REMAINING_DU_HOLDERS -gt 0 ]]; then
    echo ""
    echo "‚ö†Ô∏è  WARNING: $REMAINING_DU_HOLDERS du-holder snapshots remain!"
    echo "   These may have holds that block replication."
    echo "   Run: $0 --holds-only"
    log "WARNING: $REMAINING_DU_HOLDERS du-holder snapshots remain"
fi

if [[ $REMAINING_CLONES -gt 0 ]] || [[ $REMAINING_MOUNTS -gt 0 ]]; then
    echo ""
    echo "‚ö†Ô∏è  Some cleanup tasks incomplete"
    log "Cleanup incomplete - manual intervention may be required"
    exit 1
else
    echo ""
    echo "‚úÖ Cleanup completed successfully!"
    echo "üóëÔ∏è  All datasets and mounts have been removed"
    if [[ $REMAINING_DU_HOLDERS -eq 0 ]]; then
        echo "üîì All du-holder snapshots have been cleaned up"
    fi
    log "Cleanup completed successfully"
fi

# Note about results
if [[ -n "${ZFS_FD_RESULTS_DIR:-}" ]]; then
    echo ""
    echo "üìÑ Analysis results preserved at: $ZFS_FD_RESULTS_DIR"
    echo "üìÑ Log file at: $LOG_FILE"
    log "Analysis results preserved at: $ZFS_FD_RESULTS_DIR"
fi

log "Cleanup process complete"
